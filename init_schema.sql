
drop table if exists action;
drop table if exists clients;
drop table if exists testlog;
drop table if exists testlog_minute;

create table clients 
(
	 client_id integer  generated by default as identity
	,name varchar(256) not null
	,registation_timestamp timestamp not null
	,action_count integer not null
	,delete_timestamp timestamp null
	,primary key (client_id)
);

create table action
(
	 action_id bigint generated always as identity
	,client_id integer references clients(client_id)
	,create_timestamp timestamp not null
	,action_body text null
	,primary key (client_id, create_timestamp, action_id)
);

--custom index for 90 day (history deep) * 0.2% and 0.2% client (need support)
create index IX_ActualDateForTopClient on action (client_id, create_timestamp)
where create_timestamp >= '2022-01-21' and client_id < 20000

create table testlog
(	
	 longest_request_client_id integer not null
	,longest_request_ts_from timestamp not null
	,longest_request_ts_to timestamp not null
	
	,row_count_per_minute integer not null
	,byte_size_query_per_minute bigint not null
	,avg_time_query_per_minute integer not null
	,query_count_per_minute integer not null
	,minute_num integer not null
	
	,start_ts timestamp not null
	,description text null	
	,iteration_id bigint generated always as identity
	,primary key (minute_num, iteration_id)
);

create table testlog_minute
(	
	 client_id integer not null
	,ts_from timestamp not null
	,ts_to timestamp not null

	,row_count integer not null
	,byte_size_query bigint not null
	,ms_time_query integer not null
);


create or replace function fn_get_action(cl_id integer, ts_from timestamp, ts_to timestamp)  
returns table (
	 action_id bigint
	,client_id integer 
	,create_timestamp timestamp 
	,action_body text)
as 
$$ 
begin
	return query
	select * 
	from action as a
	where a.client_id = cl_id 
		and a.create_timestamp between ts_from and ts_to 
	order by a.create_timestamp desc; 
end;
$$ language plpgsql;

create or replace function fn_get_random_string(length integer) returns text as
$$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$ language plpgsql;


create or replace function fn_get_random_client() returns integer as
$$
declare
   client_id integer := 1;
   client_target_count integer := 0;
   random float := 0;
   start_distribution float := 0;
   end_distribution float := 0;
begin	  
	random := random();
	client_target_count := (select count(*) from clients);	
	end_distribution := fn_get_distribution(client_target_count, 1, client_id);
	
	while random not between start_distribution and end_distribution loop
    	start_distribution := end_distribution;
		client_id := client_id + 1;
		end_distribution := end_distribution + fn_get_distribution(client_target_count, 1, client_id);
	end loop;

    return client_id;	
end;
$$ language plpgsql;

create or replace function fn_get_random_date(period_days integer) returns timestamp as
$$
declare
   random_date timestamp;
   random float := 0;
   iterator_day integer := 1;
   start_distribution float := 0;
   end_distribution float := 0;
begin	
	random := random();
	end_distribution := fn_get_distribution(period_days, 1, iterator_day);
	
	while random not between start_distribution and end_distribution loop
    	start_distribution := end_distribution;
		iterator_day := iterator_day + 1;
		end_distribution := end_distribution + fn_get_distribution(period_days, 1, iterator_day);
	end loop;

	random_date := 
		now() 
			- interval '1 day' * 
		iterator_day
		 	- interval '1 day' * (random());
					 
    return random_date;
end;
$$ language plpgsql;

create or replace function fn_get_distribution(scale integer, coeff integer, x integer) returns float as
$$
declare
  distribution float := 0;
  i integer; 
  shape float := 1;
begin
  for i in 1..scale loop
	distribution := distribution + 1/(power(i, shape)) ;
  end loop;
  
  distribution := 1/power(x, shape) * coeff /distribution;
	
  return distribution;
end;
$$ language plpgsql;
